install_tinytex()
install.packages("tinytex")
install.packages("tidyverse")
tinytex::install_tinytex()
install.packages("reticulate")
reticulate::repl_python()
quit
knitr::opts_chunk$set(echo = TRUE)
reticulate::repl_python()
print("2+3 = ",2+3)
print("2-1 = ",2-1)
print("3*2 = ",3*2)
print("15/5 = ",15/5)
print("2**3 = ", 2**3)
quit()
quit()
exit()
sys.exit()
knitr::opts_chunk$set(echo = TRUE, eval = TRUE)
library(ggplot2)
B %*% A
A <- matrix(c(2,8,6,-1,3,7),
nrow = 3, ncol = 2)
B <- matrix(c(4,-5,9,2,1,4,-3,6),
nrow = 2, ncol = 4)
C = A%*%B
C
## [,1] [,2] [,3] [,4]
## [1,] 13 16 -2 -12
## [2,] 17 78 20 -6
## [3,] -11 68 34 24
B %*% A
install.packages(c("bslib", "callr", "data.table", "dbplyr", "digest", "htmltools", "knitr", "munsell", "processx", "ragg", "rstudioapi", "sass", "tinytex", "xfun"))
install.packages(c("bslib", "callr", "data.table", "dbplyr", "digest", "htmltools", "knitr", "munsell", "processx", "ragg", "rstudioapi", "sass", "tinytex", "xfun"))
install.packages(c("bslib", "callr", "data.table", "dbplyr", "digest", "htmltools", "knitr", "munsell", "processx", "ragg", "rstudioapi", "sass", "tinytex", "xfun"))
install.packages(c("digest", "htmltools", "knitr", "xfun"))
install.packages("bookdown")
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = TRUE, error = TRUE)
library(ggplot2)
library(glmnet)
library(Matrix)
library(bookdown)
\begin{equation}
f\left(k\right) = \binom{n}{k} p^k\left(1-p\right)^{n-k}
(\#eq:binom)
\end{equation}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = TRUE, error = TRUE)
library(ggplot2)
library(glmnet)
library(Matrix)
library(bookdown)
lambda = 5 ## Penalização
y_c <- y - mean(y)
X_svd <- svd(X) ## Decomposição svd
lambda = 5 ## Penalização
DD <- Diagonal(100, X_svd$d/(X_svd$d^2 + lambda))
DD[1] <- 0 ## Não penalizar o intercepto
beta_hat = as.numeric(X_svd$v%*%DD%*%t(X_svd$u)%*%y_c)
y_c <- y - mean(y)
X_svd <- svd(X) ## Decomposição svd
lambda = 0.5 ## Penalização
DD <- Diagonal(100, X_svd$d/(X_svd$d^2 + lambda))
DD[1] <- 0 ## Não penalizar o intercepto
beta_hat = as.numeric(X_svd$v%*%DD%*%t(X_svd$u)%*%y_c)
set.seed(123)
X <- matrix(NA, ncol = 200, nrow = 100)
X[,1] <- 1 ## Intercepto
for(i in 2:200) {
X[,i] <- rnorm(100, mean = 0, sd = 1)
X[,i] <- (X[,i] - mean(X[,i]))/var(X[,i])
}
## Parâmetros
beta <- rbinom(200, size = 1, p = 0.1)*rnorm(200, mean = 10)
mu <- X%*%beta
## Observações
y <- rnorm(100, mean = mu, sd = 10)
set.seed(123)
X <- matrix(NA, ncol = 200, nrow = 100)
X[,1] <- 1 ## Intercepto
for(i in 2:200) {
X[,i] <- rnorm(100, mean = 0, sd = 1)
X[,i] <- (X[,i] - mean(X[,i]))/var(X[,i])
}
## Parâmetros
beta <- rbinom(200, size = 1, p = 0.1)*rnorm(200, mean = 10)
mu <- X%*%beta
## Observações
y <- rnorm(100, mean = mu, sd = 10)
y_c <- y - mean(y)
X_svd <- svd(X) ## Decomposição svd
lambda = 0.5 ## Penalização
DD <- Diagonal(100, X_svd$d/(X_svd$d^2 + lambda))
DD[1] <- 0 ## Não penalizar o intercepto
beta_hat = as.numeric(X_svd$v%*%DD%*%t(X_svd$u)%*%y_c)
beta_glm$lambda.min
require(glmnet)
beta_glm <- cv.glmnet(X[,-1], y_c, nlambda = 100)
plot(beta_glm)
beta_glm$lambda.min
coef(beta_glm, s = "lambda.min")
#coef(beta_glm, s = "lambda.min")
```
```{r}
require(glmnet)
beta_glm <- cv.glmnet(X[,-1], y_c, nlambda = 100)
plot(beta_glm)
beta_glm$lambda.min
#coef(beta_glm, s = "lambda.min")
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = TRUE, error = TRUE)
library(ggplot2)
library(glmnet)
library(Matrix)
library(bookdown)
D(expression(13x^5  + 4x^4 +3x^2 + 78), name = "x")
D(expression(13*x^5  + 4*x^4 +3*x^2 + 78), name = "x")
D(expression(ln(2*x^5)), name = "x")
D(expression(log(exp(2*x^5))), name = "x")
f = expression(13*x^5  + 4*x^4 +3*x^2 + 78),
D( name = "x")
f = expression(13*x^5  + 4*x^4 +3*x^2 + 78)
D( f, name = "x")
f = expression(log(2*x^5, base=exp(1))
f = expression(log(exp(2*x^5)))
f = expression(log(exp(2*x^5)))
D( f, name = "x")
f = expression(log(exp(2*x^5)))
D( f, name = "x")
a = exp(2 * x^5)
a
b = (2 * (5 * x^4))
b
c = exp(2 * x^5)
c
f <- expression(log(exp(2*x^5)))
D( f, name = "x")
a <- exp(2 * x^5)
a
b <- (2 * (5 * x^4))
b
c <- exp(2 * x^5)
c
f <- expression(log(exp(2*x^5)))
D( f, name = "x")
f <- expression(ln(2*x^5))
D( f, name = "x")
f <- expression(exp(2*x^2 + 3*y))
D( f, name = "x")
f <- expression(log(2*x^5))
D( f, name = "x")
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = TRUE, error = TRUE)
library(ggplot2)
library(glmnet)
library(Matrix)
library(bookdown)
f = expression(13*x^5  + 4*x^4 +3*x^2 + 78)
D( f, name = "x")
f <- expression(log(2*x^5))
D( f, name = "x")
f <- expression(exp(2*x^2 + 3*y))
D( f, name = "x")
set.seed(123)
y <- rpois(1000, lambda = 3)
y
## gerou 1000 obs de uma poison
plot(y)
geom_histogram
grafico <- ggplot(y, aes(count)) + geom_histogram()
grafico
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(ggh4x)
install.packages("ggh4x")
library(ggplot2)
library(ggh4x)
set.seed(42)
df <- data.frame(
x = c(rpois(50, 5), rpois(50, 10)),
group = rep(c("A", "B"), each = 50)
)
ggplot(df, aes(x)) +
geom_bar(aes(fill = group, y = after_stat(prop)),
alpha = 0.5, width = 1, position = "identity") +
stat_theodensity(aes(colour = group), distri = "pois")
install.packages("Matrix")
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = TRUE, error = TRUE)
library(ggplot2)
library(glmnet)
library(Matrix)
dados_reg_log <- read.table("./Data_Files/reg_log.txt", header = TRUE)
head(dados_reg_log,n =10)
plot(dados_reg_log$Anos, dados_reg_log$Renda, main = "Anos de Exp vs Renda")
library(ggplot2)
grafico <- ggplot(dados_reg_log,aes(x = Anos, y = Renda, colour = Premium)) + geom_point()
grafico
f_logit <- function(par, y, renda, anos){
mu <- 1/(1+exp(-(par[1] + par[2]*renda + par[3]*anos)))
SQ_logit <- sum((y - mu)^2)
return(SQ_logit)
}
#f_logit()
# f_logit <- funcao(par, y, renda, anos) {
#   mu <- 1 / (1 + exp(-(par[1] + par[2] * renda + par[3] * anos)))
#   SQ_logit <- sum((y - mu) ^ 2)
#   return(SQ_logit)
# }
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = TRUE, error = TRUE)
library(ggplot2)
library(glmnet)
library(Matrix)
dados_reg_log <- read.table("./Data_Files/reg_log.txt", header = TRUE)
head(dados_reg_log,n =10)
plot(dados_reg_log$Anos, dados_reg_log$Renda, main = "Anos de Exp vs Renda")
library(ggplot2)
grafico <- ggplot(dados_reg_log,aes(x = Anos, y = Renda, colour = Premium)) + geom_point()
grafico
f_logit <- function(par, y, renda, anos){
mu <- 1/(1+exp(-(par[1] + par[2]*renda + par[3]*anos)))
SQ_logit <- sum((y - mu)^2)
return(SQ_logit)
}
#f_logit()
# f_logit <- funcao(par, y, renda, anos) {
#   mu <- 1 / (1 + exp(-(par[1] + par[2] * renda + par[3] * anos)))
#   SQ_logit <- sum((y - mu) ^ 2)
#   return(SQ_logit)
# }
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = TRUE, error = TRUE)
library(ggplot2)
library(glmnet)
library(Matrix)
minha_funcao <- function(x) {
y <- x^2
return(y)
}
x_vec <- c(-5, -4, -3, -2, -1,
0, 1, 2, 3, 4, 5) #concatenação
minha_funcao(x = x_vec) #automaticamente vetorizado
## Avaliando a função
y <- minha_funcao(x = x_vec)
## Gráfico da função
plot(y ~ x_vec, xlab = "x", type = "l",
ylab = expression(y = f(x)))
points(x_vec,y)
## ou com GGPLOT
ggplot(mapping = aes(x_vec,y))
fx <- function(x, theta) {
out <- (x - theta)^2
return(out)
}
## Criar grafico
## Criar grafico
## Criar grafico
fx1x2 <- function(x) {
y = sqrt(25 - x[1]^2 - x[2]^2)
return(y)
}
entrada1 <- c(0, 0)
entrada2 <- c(3, 0)
fx1x2(x = entrada1)
## [1] 5
fx1x2(x = entrada2)
## [1] 4
entrada <- matrix(c(entrada1, entrada2),
ncol = 2, nrow = 2,
byrow = TRUE)
entrada
## [,1] [,2]
## [1,] 0 0
## [2,] 3 0
saida <- c()
for(i in 1:2) {
saida[i] <- fx1x2(entrada[i,])
}
saida
## [1] 5 4
## Fazer grafico
# Fazer grafico
# Fazer grafico
#desenho aqui
## fazer grafico
fx <- function(x) {
out <- (x^2 - 1)/(x - 1)
return(out)
}
fx(x = 1)
## [1] NaN
## Figura 11. Desenho do gráfico da função
## Figura 12. Função descontinua.
fx <- function(x) {
out <- - x^2
return(out)
}
f_prime <- function(x) {
out <- -2*x
return(out)
}
intercept = (fx(x = 2) - f_prime(x = 2)*2)
slope <- f_prime(x = 2)
c(intercept, slope)
## [1] 4 -4
## Figura 14. Desenho de uma função e retas tangentes.
ggplot(y, aes(x = x_vec, y = y))
knitr::opts_chunk$set(echo = TRUE)
dados_reg_log <- read.table("Pokemon.csv", header = TRUE)
dados_reg_log <- read.table("Pokemon.csv", sep = ";" header = TRUE)
dados_reg_log <- read.csv2("Pokemon.csv")
head(dados_pkm,n =10)
dados_pkm <- read.csv2("Pokemon.csv")
head(dados_pkm,n =10)
dados_pkm <- read.csv2("Pokemon.csv", sep = ",")
head(dados_pkm,n =10)
ggplot(dados_pkm, aes(type1))
ggplot(dados_pkm, aes(type1)) + geom_histogram(binwidth = 5)
ggplot(dados_pkm, aes(type1)) + geom_histogram()
+ geom_histogram()
ggplot(dados_pkm, aes(type1),stat="count") +
geom_histogram()
ggplot(dados_pkm, aes(type1)) +
geom_histogram( stat = "count")
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
set.seed(123)
y <- rpois(1000, lambda = 3)
head(y)
## gerou 1000 obs de uma poison
plot(y) #grafico basico do R
ggplot(y, aes(x)) +
geom_histogram( stat = "count")
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
set.seed(123)
y <- rpois(1000, lambda = 3)
head(y)
## gerou 1000 obs de uma poison
plot(y) #grafico basico do R
ggplot(y, aes(x)) +
geom_histogram( stat = "count")
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(ggh4x)
summary(cars)
plot(pressure)
set.seed(123)
y <- rpois(1000, lambda = 3)
head(y)
## gerou 1000 obs de uma poison
plot(y) #grafico basico do R
ggplot(y, aes(x)) +
geom_histogram( stat = "count")
head(dados_pkm,n =10)
ggplot(dados_pkm, aes(type1)) +
geom_histogram( stat = "count")
ggplot(dados_pkm, aes(type1)) +
geom_histogram( stat = "count")
## Graficos mais avançados
